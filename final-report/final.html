<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">

    <title>Final Project Report CS-341 2024</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="css/bootstrap.min.css">

    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <link href="ie10-viewport-bug-workaround.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/dashboard.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">.sidebar ul{padding-left: 10px;}</style>
    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
    <link rel="stylesheet" href="icg_report.css" />
  </head>

  <body>

    <div class="container-fluid">
      <div class="row">
        <div id="sidebar" class="col-sm-3 col-md-2 sidebar">
          <!--<ul class="nav nav-sidebar">
            <li class="active"><a href="#">Overview <span class="sr-only">(current)</span></a></li>
          </ul>-->
          <ul>
          <li><a href="#volcano" id="toc-volcano">Volcano</a>
          <ul>
          <li><a href="#abstract" id="toc-abstract">Abstract</a></li>
          <li><a href="#overview" id="toc-overview">Overview</a></li>
          <li><a href="#feature-validation"
          id="toc-feature-validation">Feature validation</a>
          <ul>
          <li><a href="#procedural-volcano-terrain-generation-5-points"
          id="toc-procedural-volcano-terrain-generation-5-points">Procedural
          Volcano Terrain Generation (5 points)</a></li>
          <li><a href="#lava-flow-fluid-simulation-20-points"
          id="toc-lava-flow-fluid-simulation-20-points">Lava Flow Fluid
          Simulation (20 points)</a></li>
          <li><a href="#procedural-texture-generation"
          id="toc-procedural-texture-generation">Procedural Texture
          Generation</a></li>
          <li><a href="#smoke-particles-15-points"
          id="toc-smoke-particles-15-points">Smoke Particles (15
          points)</a></li>
          </ul></li>
          <li><a href="#discussion"
          id="toc-discussion">Discussion</a></li>
          <li><a href="#contributions"
          id="toc-contributions">Contributions</a></li>
          <li><a href="#references"
          id="toc-references">References</a></li>
          </ul></li>
          </ul>
        </div>
        <div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main">
        
<h1 id="volcano">Volcano</h1>
<figure>
<video src="videos/full_7.mp4" width="600" controls=""><a
href="videos/full_7.mp4">Volcanic island eruption</a></video>
<figcaption aria-hidden="true">Volcanic island eruption</figcaption>
</figure>
<h2 id="abstract">Abstract</h2>
<p>Volcanic eruptions are among the most awe-inspiring and powerful
natural phenomena on Earth. This project aims to faithfully reproduce
these phenomena through advanced simulation techniques. Our objective is
to create realistic volcanic scenes and develop a flexible framework
that facilitates the easy creation of diverse terrains and the design of
various types of eruptions. To achieve this adaptability, the project
embraces a procedural approach for both terrain generation and visual
effects. We aim to provide users with an intuitive and interactive
experience, allowing them to explore and manipulate volcanic
eruptions.</p>
<h2 id="overview">Overview</h2>
<p>In this project, we tackle the challenge of rendering realistic
volcanic eruptions through physically based simulations. Our framework
is designed to be flexible, allowing for the creation of various types
of eruptions with ease.</p>
<p>To achieve this goal, we begin by implementing a procedurally
generated heightmap terrain system with parameters that can be adjusted
through an intuitive UI menu. This procedural approach is chosen for its
efficiency in rapidly creating diverse terrains. The procedural
generation focuses on creating a volcanic island in the middle of the
sea.</p>
<p>The next step is to add textures to achieve a more realistic render
of the terrain. We once again choose a procedural approach for its
flexibility. Specifically, we have three kinds of procedurally generated
textures composing the terrain: the water around the island, the base
terrain of the island, and the top of the volcano.</p>
<p>To enhance the realism of the water, we implement normal mapping on
the water texture, giving the sensation of volumetric waves. Similarly,
to emphasize the “rocky” aspect of the volcano, we add normal mapping to
the volcanic terrain.</p>
<p>Then, to represent the eruption, we chose to take a particle-based
approach following the physical properties of lava flows. Thus, we
implemented a fluid simulation with added constraints on temperature and
viscosity to achieve a realistic lava flow. In particular, the
simulation is heavily based on the process described in <a
href="http://www-evasion.imag.fr/Publications/1999/SACNG99/gi99.pdf">Animating
Lava Flows</a>. We once again adopt a flexible approach that allows easy
modification of the simulation parameters, enabling users to experiment
with various eruption scenarios.</p>
<p>To add to the immersion of the scene, we chose to include a key
component of eruptions: smoke. To achieve this, we implemented a
particle system that emits “smoke” particles above the crater of the
volcano.</p>
<p>Finally, to enhance realism, we added a temperature-based rendering
of the lava particles. While the particle meshes remain independent of
each other, this approach contributes to the overall realistic
appearance of the lava.</p>
<p>With all these effects implemented, the user is now able to generate
various kinds of eruption scenarios based on realistic simulations of
flowing lava, enhanced with immersive effects to contribute to the
overall experience.</p>
<h2 id="feature-validation">Feature validation</h2>
<h3 id="procedural-volcano-terrain-generation-5-points">Procedural
Volcano Terrain Generation (5 points)</h3>
<p>The volcanic island heightmap is composed of two procedurally
generated components: the island and the volcano.</p>
<h4 id="island">Island</h4>
<h5 id="implementation">Implementation</h5>
<p>The base of the island is created from a conic shape of radius
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math>
with an inner flat area at a determined height
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>.
Beyond the flat area, the height is linearly interpolated from the
height
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
at the edge of the flat part to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
at the distance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math>.</p>
<p>This gives the following foundation for the island:</p>
<figure>
<img src="images/generation/island/process/island_base.png" width="400"
alt="Base foundation of the island terrain" />
<figcaption aria-hidden="true">Base foundation of the island
terrain</figcaption>
</figure>
<p>To create an interesting relief, we add a combination of Fractional
Brownian Motion (FBM) noises of various frequencies. A frequency factor
is made adjustable to allow the user to create terrains with varying
degrees of relief.</p>
<p>Following this implementation, we get the following result:</p>
<figure>
<img src="images/generation/island/process/island_noise.png" width="400"
alt="Simple terrain island with FBM noise" />
<figcaption aria-hidden="true">Simple terrain island with FBM
noise</figcaption>
</figure>
<p>The current result starts to resemble an island terrain but still
contains a major flaw on the sides with visible transitions that reveal
the circular shape of the island.</p>
<p>To solve this issue, we introduce a new parameter, denoted by the
transition factor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">trans</annotation></semantics></math>.
This factor determines the distance over which the smooth transition is
performed after the island radius. In this area, higher frequency FBM
noise is added to the original noise, with their amplitudes gradually
decreasing until the distance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>⋅</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">r \cdot trans</annotation></semantics></math>,
where it becomes zero.</p>
<p>The addition of higher frequency noise creates small “rocks” on the
edge of the island, giving it a more realistic look and breaking the
circular shape. After these adjustments, we achieve the following smooth
transition from the island to the water:</p>
<figure>
<img src="images/generation/island/process/island_noise_transition.png"
width="400" alt="Island terrain with transition" />
<figcaption aria-hidden="true">Island terrain with
transition</figcaption>
</figure>
<p>To fully embrace the flexibility of our model, we make the noise
offsets and the island center position adjustable. This allows users to
create different-looking islands with the same properties and to move
them around the terrain.</p>
<h5 id="validation">Validation</h5>
<p>This flexible implementation allows for the creation of various kinds
of island terrains. Here are a few possibilities offered by this
approach:</p>
<p>With a high flat proportion and a low transition factor, we can
create compact islands with a harder transition to the ocean:</p>
<figure>
<img src="images/generation/island/examples/flat.png" width="400"
alt="Compact island" />
<figcaption aria-hidden="true">Compact island</figcaption>
</figure>
<p>Conversely, setting a small radius with a high transition factor
allows for the creation of an island archipelago with a main island in
the center and smaller islands spreading around it:</p>
<figure>
<img src="images/generation/island/examples/small_islands.png"
width="400" alt="Small islands archipelago" />
<figcaption aria-hidden="true">Small islands archipelago</figcaption>
</figure>
<p>Finally, we can adjust the noise amplitude to create a
spikier-looking island:</p>
<figure>
<img src="images/generation/island/examples/spiky.png" width="400"
alt="Spiky island" />
<figcaption aria-hidden="true">Spiky island</figcaption>
</figure>
<h4 id="volcano-1">Volcano</h4>
<p>The second step to creating the volcanic island is the volcano
itself. We follow a similar approach to the island generation by
defining a base structure and adding noise on top of it.</p>
<h5 id="implementation-1">Implementation</h5>
<p>The first step is to create the global shape of the volcano. We
define a volcano using four parameters: the volcano height and radius
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>v</mi></msub><mo>,</mo><msub><mi>r</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">h_v, r_v</annotation></semantics></math>,
and the crater height and radius
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>c</mi></msub><mo>,</mo><msub><mi>r</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">h_c, r_c</annotation></semantics></math>.
For similar reasons to the island generation, we also include a
transition factor parameter, denoted
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">trans</annotation></semantics></math>.</p>
<p>We then use two functions to determine the height based on the
distance to the volcano center
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>:</p>
<ul>
<li>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&lt;</mo><msub><mi>r</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">x &lt; r_c</annotation></semantics></math>,
we use a smoothstep interpolation between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>c</mi></msub><annotation encoding="application/x-tex">h_c</annotation></semantics></math>
at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>v</mi></msub><annotation encoding="application/x-tex">h_v</annotation></semantics></math>
at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>r</mi><mi>c</mi></msub><annotation encoding="application/x-tex">r_c</annotation></semantics></math>.</li>
<li>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&gt;</mo><msub><mi>r</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">x &gt; r_c</annotation></semantics></math>,
we use a smoothstep interpolation between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>v</mi></msub><annotation encoding="application/x-tex">h_v</annotation></semantics></math>
at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>r</mi><mi>c</mi></msub><annotation encoding="application/x-tex">r_c</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>v</mi></msub><mo>⋅</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">r_v \cdot trans</annotation></semantics></math>.</li>
</ul>
<p>This creates the following basic shape of a volcano:</p>
<figure>
<img src="images/generation/volcano/process/base.png" width="400"
alt="Basic volcano shape" />
<figcaption aria-hidden="true">Basic volcano shape</figcaption>
</figure>
<p>Next, we add a combination of FBM and turbulence noise within the
volcano radius. The result is:</p>
<figure>
<img src="images/generation/volcano/process/noise.png" width="400"
alt="Volcano shape with noise" />
<figcaption aria-hidden="true">Volcano shape with noise</figcaption>
</figure>
<p>Then, we gradually remove the noise over the distance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>r</mi><mi>v</mi></msub><annotation encoding="application/x-tex">r_v</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>v</mi></msub><mo>⋅</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">r_v \cdot trans</annotation></semantics></math>,
allowing for a smooth transition. The result is shown below:</p>
<figure>
<img src="images/generation/volcano/process/noise_transition.png"
width="400" alt="Volcano shape with noise transition" />
<figcaption aria-hidden="true">Volcano shape with noise
transition</figcaption>
</figure>
<p>We also made the noise offsets and center position adjustable to
enable the creation of diverse volcanoes. Here is an example with an
offset center:</p>
<figure>
<img src="images/generation/volcano/process/move.png" width="400"
alt="Center offset volcano" />
<figcaption aria-hidden="true">Center offset volcano</figcaption>
</figure>
<h5 id="validation-1">Validation</h5>
<p>Using this framework, we can create various kinds of volcanoes. Here
are a few possibilities:</p>
<p>We can create a “small” volcano with a large crater, resulting in
steeper sides:</p>
<figure>
<img src="images/generation/volcano/examples/big_crater.png" width="400"
alt="Big crater volcano" />
<figcaption aria-hidden="true">Big crater volcano</figcaption>
</figure>
<p>We can also generate larger volcanoes:</p>
<figure>
<img src="images/generation/volcano/examples/large.png" width="400"
alt="Large volcano" />
<figcaption aria-hidden="true">Large volcano</figcaption>
</figure>
<p>Or we can adjust the noise proportion to create a spikier-looking
volcano:</p>
<figure>
<img src="images/generation/volcano/examples/spiky.png" width="400"
alt="Spiky volcano" />
<figcaption aria-hidden="true">Spiky volcano</figcaption>
</figure>
<h4 id="combined">Combined</h4>
<h5 id="implementation-2">Implementation</h5>
<p>We then simply combine both heightmaps by adding them.</p>
<h5 id="validation-2">Validation</h5>
<p>These implementations of the island and volcano heightmaps allow for
the creation of various types of volcanic islands. Here are a few
variations:</p>
<p>Here is a normal, pretty small volcanic island:</p>
<figure>
<img src="images/generation/combined/normal/normal.png" width="400"
alt="Normal volcanic island" />
<figcaption aria-hidden="true">Normal volcanic island</figcaption>
</figure>
<p>And here are some top views where we vary the island transition
parameter to highlight its influence:</p>
<figure>
<img src="images/generation/combined/normal/normal_top.png" width="400"
alt="Top view, small transition factor" />
<figcaption aria-hidden="true">Top view, small transition
factor</figcaption>
</figure>
<figure>
<img src="images/generation/combined/normal/normal_transition.png"
width="400" alt="Top view, high transition factor" />
<figcaption aria-hidden="true">Top view, high transition
factor</figcaption>
</figure>
<p>We can create large volcanoes:</p>
<figure>
<img src="images/generation/combined/big_volcano/big_volcano.png"
width="400" alt="Large volcano" />
<figcaption aria-hidden="true">Large volcano</figcaption>
</figure>
<p>We can reduce the terrain size to get a close-up view of a
volcano:</p>
<figure>
<img src="images/generation/combined/close_up/close.png" width="400"
alt="Close up view of volcano" />
<figcaption aria-hidden="true">Close up view of volcano</figcaption>
</figure>
<p>Setting a large island radius, we can create a terrain with no
water:</p>
<figure>
<img src="images/generation/combined/no_water/no_water.png" width="400"
alt="No water volcano" />
<figcaption aria-hidden="true">No water volcano</figcaption>
</figure>
<p>Using the same parameters with various noise offsets, we can generate
diverse volcanic islands:</p>
<figure>
<img src="images/generation/combined/noise/1.png" width="400"
alt="Noise offset 0" />
<figcaption aria-hidden="true">Noise offset 0</figcaption>
</figure>
<figure>
<img src="images/generation/combined/noise/2.png" width="400"
alt="Noise offset 1" />
<figcaption aria-hidden="true">Noise offset 1</figcaption>
</figure>
<figure>
<img src="images/generation/combined/noise/3.png" width="400"
alt="Noise offset 2" />
<figcaption aria-hidden="true">Noise offset 2</figcaption>
</figure>
<h4 id="menu">Menu</h4>
<p>To improve the user experience when designing a volcanic island, we
have incorporated a menu that allows users to adjust all the generation
parameters easily. There are a total of 17 different generation
parameters that can be tweaked.</p>
<p>The menu can be closed or opened to avoid wasting view space:</p>
<figure>
<img src="images/generation/menu/closed.png" width="400"
alt="Menu closed" />
<figcaption aria-hidden="true">Menu closed</figcaption>
</figure>
<figure>
<img src="images/generation/menu/opened.png" width="400"
alt="Menu open" />
<figcaption aria-hidden="true">Menu open</figcaption>
</figure>
<p>Fully opened, the menu consists of the following sections to adjust
the parameters:</p>
<figure>
<img src="images/generation/menu/details/buttons.png" width="200"
alt="Apply buttons" />
<figcaption aria-hidden="true">Apply buttons</figcaption>
</figure>
<figure>
<img src="images/generation/menu/details/terrain.png" width="200"
alt="Terrain parameters" />
<figcaption aria-hidden="true">Terrain parameters</figcaption>
</figure>
<figure>
<img src="images/generation/menu/details/volcano.png" width="200"
alt="Volcano parameters" />
<figcaption aria-hidden="true">Volcano parameters</figcaption>
</figure>
<figure>
<img src="images/generation/menu/details/island.png" width="200"
alt="Island parameters" />
<figcaption aria-hidden="true">Island parameters</figcaption>
</figure>
<p>In particular, one can set various kinds of resolution depending on
the performance/quality desired:</p>
<figure>
<img src="images/generation/resolution/resolutions.gif" width="400"
alt="Side resolutions: 64 to 2048" />
<figcaption aria-hidden="true">Side resolutions: 64 to 2048</figcaption>
</figure>
<h3 id="lava-flow-fluid-simulation-20-points">Lava Flow Fluid Simulation
(20 points)</h3>
<p>This feature aims to provide a convincing flow of lava. To achieve
this goal, we’ll perform a particle-based simulation with additional
constraints. Our work is highly inspired by the implementation proposed
in <a
href="http://www-evasion.imag.fr/Publications/1999/SACNG99/gi99.pdf">Animating
Lava Flows</a>.</p>
<h4 id="global-concepts">Global Concepts</h4>
<p>Firstly, each particle will have a radius of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>r</mi><mi>p</mi></msub><annotation encoding="application/x-tex">r_p</annotation></semantics></math>
and an initial density
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mn>0</mn></msub><mo>=</mo><mn>2500</mn><mspace width="0.278em"></mspace><msup><mtext mathvariant="normal">kg/m</mtext><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">\rho_0 = 2500 \; \text{kg/m}^3</annotation></semantics></math>.
We then have a kernel that describes the particle mass distribution in
space. We use the kernel function proposed by <a
href="http://www.geometry.caltech.edu/pubs/DC_EW96.pdf">Smoother
Particles: A new paradigm for highly deformable bodies</a>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>h</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="bold">𝐫</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac displaystyle="true"><mn>15</mn><mrow><mi>π</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>4</mn><mi>h</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>3</mn></msup></mrow></mfrac><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>−</mo><mfrac><mi>r</mi><mi>h</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>3</mn></msup><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mn>0</mn><mo>≤</mo><mi>r</mi><mo>≤</mo><mn>2</mn><mi>h</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>0</mn><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>r</mi><mo>&gt;</mo><mn>2</mn><mi>h</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
W_h(\textbf{r}) = \dfrac{15}{\pi(4h)^3} \begin{cases}
    (2 - \frac{r}{h})^3 \quad \text{if } 0 \leq r \leq 2h \\
    0 \quad \text{if } r &gt; 2h
\end{cases}
</annotation></semantics></math></p>
<p>Note that the particle mass
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>m</mi><mi>p</mi></msub><annotation encoding="application/x-tex">m_p</annotation></semantics></math>
and the kernel parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
are constrained by the particle radius.</p>
<p>Then, we say that two particles are neighbors if they are at a
distance lower than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>h</mi></mrow><annotation encoding="application/x-tex">2h</annotation></semantics></math>
from one another.</p>
<p>A high-level view of the simulation is as follows: For each timestep,
we first compute all the forces that apply to each particle. Then, we
integrate the ODE using the integration method of our choice. Finally,
we update the particle characteristics for the next iteration.</p>
<h4 id="pressure-force">Pressure Force</h4>
<h5 id="implementation-3">Implementation</h5>
<p>The pressure of a particle is determined by the formula:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mi>k</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>ρ</mi><mo>−</mo><msub><mi>ρ</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
P = k (\rho - \rho_0)
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
is the incompressibility factor and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>
is the current density of the particle computed as follows for particle
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mi>i</mi></msub><mo>=</mo><msub><mo>∑</mo><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>W</mi><mi>h</mi><mrow><mi>i</mi><mi>j</mi></mrow></msubsup><msub><mi>m</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\rho_i = \sum_{j} (W_h^{ij} m_j)</annotation></semantics></math>.
More details can be found in <a
href="http://www-evasion.imag.fr/Publications/1999/SACNG99/gi99.pdf">Animating
Lava Flows</a>.</p>
<p>From the pressure, we can compute the resulting force exerted on the
particle. Note that because the kernel
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>W</mi><mi>h</mi><mrow><mi>i</mi><mi>j</mi></mrow></msubsup><annotation encoding="application/x-tex">W_h^{ij}</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
if the particles
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
are at a distance greater than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>h</mi></mrow><annotation encoding="application/x-tex">2h</annotation></semantics></math>
(i.e., not neighbors), the summation can be performed only on the
particle’s neighbors.</p>
<figure>
<img src="images/simulation/features/pressure/pressure_force.png"
width="300" alt="Pressure force" />
<figcaption aria-hidden="true">Pressure force</figcaption>
</figure>
<h5 id="validation-3">Validation</h5>
<p>We can test this feature by only applying the pressure forces on the
particles. Because we spawn the particles on a 2-dimensional plane and
no other forces are taken into account, the particles will stay in this
plane.</p>
<p>The following video presents the action of pressure force:</p>
<figure>
<video src="images/simulation/features/pressure/pressure_demo_200.mp4"
width="300" controls=""><a
href="images/simulation/features/pressure/pressure_demo_200.mp4">Pressure
force</a></video>
<figcaption aria-hidden="true">Pressure force</figcaption>
</figure>
<h4 id="viscosity-force">Viscosity Force</h4>
<h5 id="implementation-4">Implementation</h5>
<p>We compute the force from viscosity applied to a particle using the
formula:</p>
<figure>
<img src="images/simulation/features/viscosity/viscosity_force.png"
width="300" alt="Viscosity force" />
<figcaption aria-hidden="true">Viscosity force</figcaption>
</figure>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">v_{ij}</annotation></semantics></math>
is the relative speed difference between particles
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>.
This formula implies that a particle will be “attracted” by the flowing
particles around it, which is the behavior we are looking for to
simulate viscosity. Also,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>v</mi></msub><annotation encoding="application/x-tex">\alpha_v</annotation></semantics></math>
is a parameter dependent on the particle temperature, but we consider it
constant for now. We’ll detail it further when considering temperature
exchanges.</p>
<h5 id="validation-4">Validation</h5>
<p>We can add viscosity forces on top of the previous simulation to get
the following result:</p>
<figure>
<video src="images/simulation/features/viscosity/viscosity_demo.mp4"
width="300" controls=""><a
href="images/simulation/features/viscosity/viscosity_demo.mp4">Viscosity
force</a></video>
<figcaption aria-hidden="true">Viscosity force</figcaption>
</figure>
<p>As we can see, the particles are now moving in <em>blocks</em>, which
is the expected behavior with viscosity.</p>
<h4 id="gravity">Gravity</h4>
<h5 id="implementation-5">Implementation</h5>
<p>The next step for our simulation is to add the gravity force.</p>
<p>This force can be easily computed by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><msub><mi>F</mi><mi>g</mi></msub><mo accent="true">→</mo></mover><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mo>−</mo><mi>m</mi><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{F_g} = (0,0,-mg)</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mn>9.81</mn><mspace width="0.278em"></mspace><msup><mtext mathvariant="normal">m/s</mtext><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">g=9.81 \; \text{m/s}^2</annotation></semantics></math>.</p>
<h5 id="validation-5">Validation</h5>
<p>We now add the gravity force to the simulation to get the following
result:</p>
<figure>
<video src="images/simulation/features/gravity/gravity_demo_better.mp4"
width="300" controls=""><a
href="images/simulation/features/gravity/gravity_demo_better.mp4">Gravity
force</a></video>
<figcaption aria-hidden="true">Gravity force</figcaption>
</figure>
<p>As expected, the particles are now falling, passing through the floor
because collisions are not yet implemented.</p>
<h4 id="ground-collision">Ground Collision</h4>
<h5 id="implementation-6">Implementation</h5>
<p>To simulate flows, we need to account for collisions with the ground.
After experimenting with various methods, we chose a simple
implementation of ground collisions.</p>
<p>At each iteration, we check if any particles are below the ground. If
so, we force their position to be on the ground. Moreover, to simulate
the effect of lava adhering to the ground, we set the particle velocity
to 0. This approach allows us to achieve convincing flows with a very
simple implementation and ensures that no particles pass through the
ground, which could happen with a force-based approach due to
instabilities in the simulation. For these reasons, we chose this
method.</p>
<h5 id="validation-6">Validation</h5>
<p>To test the collision, we can simply emit particles above a plane as
shown below:</p>
<figure>
<video
src="images/simulation/features/ground_collision/ground_collision_demo.mp4"
width="300" controls=""><a
href="images/simulation/features/ground_collision/ground_collision_demo.mp4">Ground
collision</a></video>
<figcaption aria-hidden="true">Ground collision</figcaption>
</figure>
<p>Moreover, we now have the necessary basis to create a first, very
basic flow:</p>
<figure>
<video
src="images/simulation/features/ground_collision/simple_flow_demo.mp4"
width="300" controls=""><a
href="images/simulation/features/ground_collision/simple_flow_demo.mp4">Basic
flow</a></video>
<figcaption aria-hidden="true">Basic flow</figcaption>
</figure>
<p>As we can see, we get a viscous fluid, which is what we are looking
for to animate lava.</p>
<h4 id="ground-temperature-transfer">Ground Temperature Transfer</h4>
<h5 id="implementation-7">Implementation</h5>
<p>To implement temperature transfers with the ground, we apply the
following temperature variation to all particles that are in ground
collision:</p>
<figure>
<img
src="images/simulation/features/ground_transfer/ground_transfer.png"
width="300" alt="Ground temperature transfer formula" />
<figcaption aria-hidden="true">Ground temperature transfer
formula</figcaption>
</figure>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>r</mi><mi>i</mi></msub><annotation encoding="application/x-tex">r_i</annotation></semantics></math>
is the particle radius,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mrow><mi>e</mi><mi>x</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">T_{ext}</annotation></semantics></math>
is the temperature of the ground, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>k</mi><mrow><mi>e</mi><mi>x</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">k_{ext}</annotation></semantics></math>
is the heat transfer coefficient between the ground and our lava
particles. From this formula, we can determine the variation in
temperature of particles on the ground at each timestep.</p>
<h5 id="validation-7">Validation</h5>
<p>We can test this by letting a flow on the ground. To visualize the
temperature, we link it to the particle color, transitioning from hotter
to colder as follows:</p>
<p>Yellow -&gt; Red -&gt; Black</p>
<p>We can visualize the temperature transfer below:</p>
<figure>
<video
src="images/simulation/features/ground_transfer/ground_trans_top.mp4"
width="300" controls=""><a
href="images/simulation/features/ground_transfer/ground_trans_top.mp4">Ground
temperature transfer (Top view)</a></video>
<figcaption aria-hidden="true">Ground temperature transfer (Top
view)</figcaption>
</figure>
<figure>
<video
src="images/simulation/features/ground_transfer/ground_trans_bottom.mp4"
width="300" controls=""><a
href="images/simulation/features/ground_transfer/ground_trans_bottom.mp4">Ground
temperature transfer (Bottom view)</a></video>
<figcaption aria-hidden="true">Ground temperature transfer (Bottom
view)</figcaption>
</figure>
<p>We can see that the particles on the ground have their temperature
decrease, which is the expected behavior.</p>
<h4 id="surface-temperature-transfer">Surface Temperature Transfer</h4>
<h5 id="implementation-8">Implementation</h5>
<p>To detect if a particle is at the surface, we check if among its
neighbors there is a particle above its center. This simple
implementation allows us to efficiently categorize whether a particle is
at the surface of the flow.</p>
<p>Then, the same formula as for ground transfers is used:</p>
<figure>
<img
src="images/simulation/features/ground_transfer/ground_transfer.png"
width="300" alt="Surface temperature transfer formula" />
<figcaption aria-hidden="true">Surface temperature transfer
formula</figcaption>
</figure>
<h5 id="validation-8">Validation</h5>
<p>The following video displays temperature transfers involving only
surface particles:</p>
<figure>
<video
src="images/simulation/features/surface_transfer/surface_trans_demo.mp4"
width="300" controls=""><a
href="images/simulation/features/surface_transfer/surface_trans_demo.mp4">Surface
temperature transfer</a></video>
<figcaption aria-hidden="true">Surface temperature transfer</figcaption>
</figure>
<p>We can see that the surface particles have their temperature
decreasing, which is the expected behavior.</p>
<h4 id="internal-temperature-transfer">Internal Temperature
Transfer</h4>
<h5 id="implementation-9">Implementation</h5>
<p>The final step in temperature simulation is to consider the transfer
between the particles themselves. To achieve this, we follow the formula
proposed in <a
href="http://www-evasion.imag.fr/Publications/1999/SACNG99/gi99.pdf">Animating
Lava Flows</a>:</p>
<figure>
<img
src="images/simulation/features/particle_transfers/internal_trans.png"
width="150" alt="Internal temperature transfer" />
<figcaption aria-hidden="true">Internal temperature
transfer</figcaption>
</figure>
<p>The temperature Laplacian
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">\Delta T</annotation></semantics></math>
is computed from the gradient using the following formula:</p>
<figure>
<img src="images/simulation/features/particle_transfers/lap_grad.png"
width="300" alt="Temperature Laplacian" />
<figcaption aria-hidden="true">Temperature Laplacian</figcaption>
</figure>
<h5 id="validation-9">Validation</h5>
<p>To demonstrate internal temperature transfer, we must also account
for some form of external transfer. Without it, no heat loss occurs, and
the particles remain at the same temperature. Therefore, in the
following examples, we consider both ground and internal transfers.</p>
<p>We highlight the internal transfer by comparing scenarios with and
without considering it.</p>
<figure>
<video
src="images/simulation/features/particle_transfers/with_internal_trans.mp4"
width="300" controls=""><a
href="images/simulation/features/particle_transfers/with_internal_trans.mp4">With
internal temperature transfer</a></video>
<figcaption aria-hidden="true">With internal temperature
transfer</figcaption>
</figure>
<figure>
<video
src="images/simulation/features/particle_transfers/without_internal_trans.mp4"
width="300" controls=""><a
href="images/simulation/features/particle_transfers/without_internal_trans.mp4">Without
internal temperature transfer</a></video>
<figcaption aria-hidden="true">Without internal temperature
transfer</figcaption>
</figure>
<p>As expected, with internal transfers, the heat loss is propagated to
particles that are not in direct contact with the ground. This is the
desired behavior, as it more accurately simulates the diffusion of heat
within the lava flow.</p>
<h4 id="temperature-based-viscosity">Temperature-Based Viscosity</h4>
<h5 id="implementation-10">Implementation</h5>
<p>To achieve a realistic simulation of lava flow, it is crucial to
consider that the viscosity of the flow increases exponentially as the
temperature decreases. This relationship is captured by the factor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>v</mi></msub><annotation encoding="application/x-tex">\alpha_v</annotation></semantics></math>,
used previously to compute viscosity. The factor is computed as
follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>v</mi></msub><mo>=</mo><mi>b</mi><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mi>a</mi><mfrac><mi>T</mi><msub><mi>T</mi><mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\alpha_v = b \exp \left( -a \frac{T}{T_{initial}} \right)
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
are parameters chosen to match the desired behavior. In our simulation,
we use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><msup><mn>10</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">a = 10^6</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>1.5</mn></mrow><annotation encoding="application/x-tex">b = 1.5</annotation></semantics></math>.</p>
<h5 id="validation-10">Validation</h5>
<p>To demonstrate the effect of this feature, we present the flow of
particles at different temperatures.</p>
<figure>
<video
src="images/simulation/features/viscosity_temp/viscosity_temp_high.mp4"
width="300" controls=""><a
href="images/simulation/features/viscosity_temp/viscosity_temp_high.mp4">Hot
lava flow (1200 °C)</a></video>
<figcaption aria-hidden="true">Hot lava flow (1200 °C)</figcaption>
</figure>
<figure>
<video
src="images/simulation/features/viscosity_temp/viscosity_temp_low.mp4"
width="300" controls=""><a
href="images/simulation/features/viscosity_temp/viscosity_temp_low.mp4">Cold
lava flow (600 °C)</a></video>
<figcaption aria-hidden="true">Cold lava flow (600 °C)</figcaption>
</figure>
<p>It is evident that the cold lava flow does not expand as much as the
hot flow. This behavior aligns with the expectation that the cold flow
is more viscous.</p>
<h4 id="integration-method">Integration Method</h4>
<h5 id="implementation-11">Implementation</h5>
<p>After computing all the derivatives of each parameter at a given
timestep, it is necessary to integrate the ordinary differential
equations (ODEs) to determine the parameters for the next step.</p>
<p>Initially, we employed the Euler Explicit method due to its
simplicity. However, despite its ease of implementation, this method
lacks stability and only converges for the first order. Consequently, a
very small timestep is required to maintain stable simulations, which
significantly increases computation time.</p>
<p>To address this issue, we transitioned to the Runge-Kutta order 2
method. Although the implementation of this method is more complex, it
offers superior stability for our simulations (at order 2), allowing us
to use a larger timestep.</p>
<p>Both methods have been retained in the implementation, enabling users
to select the appropriate method based on their needs. For our
simulations, we predominantly use the Runge-Kutta 2 method.</p>
<h5 id="validation-11">Validation</h5>
<p>To illustrate the advantages provided by the Runge-Kutta 2 method, we
conducted two simulations with identical parameters: one using the Euler
Explicit method and the other using the Runge-Kutta 2 method.</p>
<figure>
<video src="images/simulation/features/stability/euler_explicit.mp4"
width="300" controls=""><a
href="images/simulation/features/stability/euler_explicit.mp4">Euler
Explicit method</a></video>
<figcaption aria-hidden="true">Euler Explicit method</figcaption>
</figure>
<figure>
<video src="images/simulation/features/stability/runge_kutta.mp4"
width="300" controls=""><a
href="images/simulation/features/stability/runge_kutta.mp4">Runge-Kutta
order 2</a></video>
<figcaption aria-hidden="true">Runge-Kutta order 2</figcaption>
</figure>
<p>The simulation using the Euler Explicit method rapidly becomes
unstable and unusable. In contrast, the simulation using the Runge-Kutta
2 method remains stable and produces convincing results. This comparison
underscores the importance of the integration method in our
simulation.</p>
<h4 id="optimization">Optimization</h4>
<h5 id="implementation-12">Implementation</h5>
<p>The current implementation yields convincing results, but a
significant performance issue remains. At each timestep, we need to
determine the neighbors of each particle (particles that are within a
distance of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>2</mn><mi>h</mi></mrow><annotation encoding="application/x-tex">&lt; 2h</annotation></semantics></math>).</p>
<p>The straightforward approach is to loop over all particles for each
particle to identify its neighbors. While simple, this method results in
a quadratic time complexity with respect to the number of particles,
making the simulation extremely slow as the number of particles
increases.</p>
<p>To overcome this problem, we perform the following optimization: We
divide the simulated terrain into a grid where each cell is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>h</mi></mrow><annotation encoding="application/x-tex">2h</annotation></semantics></math>
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>h</mi></mrow><annotation encoding="application/x-tex">2h</annotation></semantics></math>.
Each particle is assigned to a cell based on its position. For the
neighbor search, we only need to examine the current cell and the 8
surrounding cells. This approach allows for an almost constant time
lookup for neighbors. After each timestep, the particles’ positions in
the grid are updated.</p>
<p>As a result, the neighbor search becomes almost linear in complexity,
making simulations with a high number of particles feasible.</p>
<h5 id="validation-12">Validation</h5>
<p>To demonstrate the benefits of our optimization, we performed the
simulation of the following scene with and without the optimization and
recorded the time required to bake the simulation.</p>
<figure>
<video src="images/simulation/features/grid/demo.mp4" width="300"
controls=""><a href="images/simulation/features/grid/demo.mp4">Basic
simulation</a></video>
<figcaption aria-hidden="true">Basic simulation</figcaption>
</figure>
<table>
<caption>
Optimisation baking times
</caption>
<thead>
<tr>
<th>
Neighbor search method
</th>
<th>
Baking time
</th>
</tr>
</thead>
<thead>
<tr>
<th>
Loop
</th>
<th>
5m19s
</th>
</tr>
</thead>
<thead>
<tr>
<th>
Grid
</th>
<th>
44.5s
</th>
</tr>
</thead>
</table>
<p>The simulation using the grid method is more than seven times faster
than the simple loop method. This highlights the significant impact of
the neighbor search implementation on the simulation’s performance.</p>
<h4 id="scheduling-mechanism">Scheduling Mechanism</h4>
<h5 id="implementation-13">Implementation</h5>
<p>An important aspect of our project is to provide a simple way to
create eruptions. This requires a straightforward interface for
generating various flows. We chose to expose an interface that allows
the user to specify the emission schedule with key points.</p>
<p>The format for each key is as follows:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span> <span class="dt">&quot;start_time&quot;</span><span class="fu">:</span> <span class="st">&quot;&quot;</span><span class="fu">,</span> <span class="dt">&quot;duration&quot;</span><span class="fu">:</span> <span class="st">&quot;&quot;</span><span class="fu">,</span> <span class="dt">&quot;particles_per_second&quot;</span><span class="fu">:</span> <span class="st">&quot;&quot;</span> <span class="fu">}</span></span></code></pre></div>
<p>Each key is placed in a list, and the emission follows this
schedule.</p>
<h5 id="validation-13">Validation</h5>
<p>This approach allows us to simulate eruptions by emitting a large
number of particles over a short period. For instance, we use the
following schedule:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">[</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">{</span> <span class="dt">&quot;start_time&quot;</span><span class="fu">:</span> <span class="dv">0</span><span class="fu">,</span> <span class="dt">&quot;duration&quot;</span><span class="fu">:</span> <span class="dv">2</span><span class="fu">,</span> <span class="dt">&quot;particles_per_second&quot;</span><span class="fu">:</span> <span class="dv">3000</span> <span class="fu">}</span><span class="ot">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">{</span> <span class="dt">&quot;start_time&quot;</span><span class="fu">:</span> <span class="dv">2</span><span class="fu">,</span> <span class="dt">&quot;duration&quot;</span><span class="fu">:</span> <span class="dv">10</span><span class="fu">,</span> <span class="dt">&quot;particles_per_second&quot;</span><span class="fu">:</span> <span class="dv">200</span> <span class="fu">}</span><span class="ot">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">{</span> <span class="dt">&quot;start_time&quot;</span><span class="fu">:</span> <span class="dv">15</span><span class="fu">,</span> <span class="dt">&quot;duration&quot;</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span> <span class="dt">&quot;particles_per_second&quot;</span><span class="fu">:</span> <span class="dv">3000</span> <span class="fu">}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ot">]</span></span></code></pre></div>
<p>This schedule produces the following simulation:</p>
<figure>
<video src="images/simulation/features/scheduling/eruption.mp4"
width="300" controls=""><a
href="images/simulation/features/scheduling/eruption.mp4">Eruption</a></video>
<figcaption aria-hidden="true">Eruption</figcaption>
</figure>
<p>We observe that the simulation creates an eruption-like effect, which
aligns with our project goals.</p>
<h4 id="examples">Examples</h4>
<p>Here, we present an example of integrating the simulation with the
previously developed terrain features.</p>
<figure>
<video
src="images/simulation/features/examples/example_1/good/demo_1.mp4"
width="300" controls=""><a
href="images/simulation/features/examples/example_1/good/demo_1.mp4">Full
view</a></video>
<figcaption aria-hidden="true">Full view</figcaption>
</figure>
<figure>
<video
src="images/simulation/features/examples/example_1/good/demo_2.mp4"
width="300" controls=""><a
href="images/simulation/features/examples/example_1/good/demo_2.mp4">Crater
view</a></video>
<figcaption aria-hidden="true">Crater view</figcaption>
</figure>
<figure>
<video
src="images/simulation/features/examples/example_1/good/demo_4.mp4"
width="300" controls=""><a
href="images/simulation/features/examples/example_1/good/demo_4.mp4">Flow
view</a></video>
<figcaption aria-hidden="true">Flow view</figcaption>
</figure>
<figure>
<video
src="images/simulation/features/examples/example_1/good/demo_3.mp4"
width="300" controls=""><a
href="images/simulation/features/examples/example_1/good/demo_3.mp4">Top
view</a></video>
<figcaption aria-hidden="true">Top view</figcaption>
</figure>
<p>To highlight the critical importance of selecting an appropriate
timestep, we demonstrate the consequences of setting the timestep too
large. Even with the Runge-Kutta 2 method, an improperly chosen timestep
can lead to instability in the simulation. The following video
illustrates the outcome when the timestep is excessively large:</p>
<figure>
<video
src="images/simulation/features/examples/example_1/catastrophic_failure/catastrophic_failure.mp4"
width="300" controls=""><a
href="images/simulation/features/examples/example_1/catastrophic_failure/catastrophic_failure.mp4">Timestep
too large</a></video>
<figcaption aria-hidden="true">Timestep too large</figcaption>
</figure>
<h3 id="procedural-texture-generation">Procedural Texture
Generation</h3>
<p>In order to make the terrain more realistic and give it vivid-looking
appearance, different textures are tried out to provide this visual
effect. This includes the concepts of perlin noise, fractal Brownian
motion, noise-based displacement，cell noise, cellullar pattern, normal
mapping, blending and etc.</p>
<h4 id="implementation-normal-mapping">Implementation (Normal
mapping)</h4>
<h4 id="validation-14">Validation</h4>
<figure>
<img src="images/texture/normal_mapping.gif" width="400"
alt="Normal Mapping" />
<figcaption aria-hidden="true">Normal Mapping</figcaption>
</figure>
<h4 id="implementation-volcano">Implementation (Volcano)</h4>
<h4 id="validation-15">Validation</h4>
<figure>
<img src="images/texture/mountain_texture.gif" width="400"
alt="Mountain Texture" />
<figcaption aria-hidden="true">Mountain Texture</figcaption>
</figure>
<figure>
<img src="images/texture/mountain_rock_blend.gif" width="400"
alt="Mountain/Rock Blend Texture" />
<figcaption aria-hidden="true">Mountain/Rock Blend Texture</figcaption>
</figure>
<h4 id="implementation-water">Implementation (Water)</h4>
<h4 id="implementation-14">Implementation</h4>
<p>TODO</p>
<h4 id="validation-16">Validation</h4>
<figure>
<img src="images/texture/water_texture_rim.png" width="400"
alt="Water Texture (highlighted rims)" />
<figcaption aria-hidden="true">Water Texture (highlighted
rims)</figcaption>
</figure>
<figure>
<img src="images/texture/water_texture_cell.png" width="400"
alt="Water Texture (highlighted regions)" />
<figcaption aria-hidden="true">Water Texture (highlighted
regions)</figcaption>
</figure>
<figure>
<img src="images/texture/water_texture_moving.gif" width="400"
alt="Water Texture (combined with normals and sampled with time)" />
<figcaption aria-hidden="true">Water Texture (combined with normals and
sampled with time)</figcaption>
</figure>
<h4 id="implementation-lava-particles">Implementation (Lava
Particles)</h4>
<p>TODO</p>
<h4 id="validation-17">Validation</h4>
<figure>
<img src="images/texture/lava_texture_overview.png" width="400"
alt="Lava Texture" />
<figcaption aria-hidden="true">Lava Texture</figcaption>
</figure>
<figure>
<img src="images/texture/lava_texture.png" width="400"
alt="Lava Texture (Zoom-in)" />
<figcaption aria-hidden="true">Lava Texture (Zoom-in)</figcaption>
</figure>
<figure>
<img src="images/texture/lava_texture_ramdom_geo.png" width="400"
alt="Lava Texture (Ramdomized Geometry)" />
<figcaption aria-hidden="true">Lava Texture (Ramdomized
Geometry)</figcaption>
</figure>
<h3 id="smoke-particles-15-points">Smoke Particles (15 points)</h3>
<h4 id="implementation-15">Implementation</h4>
<p>The smoke effect is a combination of multiple small particles. Every
particle is a partially transparent ellipse. It has a position in the
world and always faces the camera. Every particle rises up for a random
amount of time, becoming dimmer and then disappearing.</p>
<h4 id="validation-18">Validation</h4>
<p><video src="videos/smoke/single.mp4" width="600" controls=""><a
href="videos/smoke/single.mp4">Single smoke particle</a></video> <video
src="videos/smoke/full.mp4" width="600" controls=""><a
href="videos/smoke/full.mp4">Full smoke effect</a></video></p>
<h2 id="discussion">Discussion</h2>
<p>We initially planned to perform a Voronoi tessellation of the
particle system to generate a smooth mesh of the lava flow. However,
after further research, we realized that there were limited resources
available for our specific case, which involves three dimensions.
Additionally, incorporating temporal coherence into the tessellation to
avoid erratic changes in the mesh structure at each timestep posed a
significant challenge. Given that the fluid simulation itself was
already complex, implementing this feature within our timeframe was not
feasible. Consequently, we decided against pursuing the Voronoi
tessellation.</p>
<p>Instead, we opted for normal mapping of the terrain to achieve a
rocky appearance and of the water to give volume to the waves. This
decision enabled us to deliver relevant features while adhering to the
project deadlines.</p>
<p>Another challenge was the display of the simulation. Initially, we
aimed to perform a real-time simulation. However, we quickly realized
that this approach would not yield satisfactory results, likely
resulting in the simulation running at a fraction of real-time speed.
Therefore, we adopted a pre-computation approach. The simulation is
fully executed, and the particle positions and temperatures are sampled
at a predefined rate and stored in memory. Once the baking process is
complete, the simulation can be played back in real-time. This method
also offers the added benefit of allowing the simulation to be replayed
quickly without the need for re-computation, as the data is stored in
memory.</p>
<h2 id="contributions">Contributions</h2>
<table>
<caption>
Worked hours
</caption>
<thead>
<tr>
<th>
Name
</th>
<th>
Week 1
</th>
<th>
Week 2
</th>
<th>
Week 3
</th>
<th>
Week 4
</th>
<th>
Week 5
</th>
<th>
Week 6
</th>
<th>
Total
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
Yoann Lafore
</td>
<td>
8
</td>
<td>
10
</td>
<td>
10
</td>
<td>
19
</td>
<td>
6
</td>
<td>
7
</td>
<td>
60
</td>
</tr>
<tr>
<td>
Name 2
</td>
<td>
TODO
</td>
<td>
TODO
</td>
<td>
TODO
</td>
<td>
TODO
</td>
<td>
TODO
</td>
<td>
TODO
</td>
<td>
TODO
</td>
</tr>
<tr>
<td>
Name 3
</td>
<td>
TODO
</td>
<td>
TODO
</td>
<td>
TODO
</td>
<td>
TODO
</td>
<td>
TODO
</td>
<td>
TODO
</td>
<td>
TODO
</td>
</tr>
</tbody>
</table>
<table>
<caption>
Individual contributions
</caption>
<thead>
<tr>
<th>
Name
</th>
<th>
Contribution
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
Yoann Lafore
</td>
<td>
1/3
</td>
</tr>
<tr>
<td>
Name 2
</td>
<td>
1/3
</td>
</tr>
<tr>
<td>
Name 3
</td>
<td>
1/3
</td>
</tr>
</tbody>
</table>
<h4 id="comments">Comments</h4>
<p>TODO</p>
<h2 id="references">References</h2>
<p>TODO</p>
        </div>
      </div>
    </div>
    
    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="js/jquery.min.js"></script>
		<script src="js/bootstrap.min.js"></script>
    <script>
        //document.getElementById('sidebar').getElementsByTagName('ul')[0].className += "nav nav-sidebar";
        
        /* ajust the height when click the toc
           the code is from https://github.com/twbs/bootstrap/issues/1768
        */
        var shiftWindow = function() { scrollBy(0, -50) };
        window.addEventListener("hashchange", shiftWindow);
        function load() { if (window.location.hash) shiftWindow(); }
        
        /*add Bootstrap styles to tables*/
        var tables = document.getElementsByTagName("table");
        for(var i = 0; i < tables.length; ++i){
            tables[i].className += "table table-bordered table-hover";
        }
    </script>
  </body>
</html>
